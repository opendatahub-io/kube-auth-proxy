name: Security Full Codebase Scan

# This workflow performs comprehensive security scanning on the ENTIRE codebase.
# Complements CodeRabbit's PR incremental scanning with full repository validation.
#
# Trigger modes:
# - Manual: workflow_dispatch (on-demand PoC testing)
# - Scheduled: Weekly on Sundays at 00:00 UTC (optional baseline)
# - On-demand: Can be triggered via GitHub UI or gh CLI

on:
  workflow_dispatch:  # Manual trigger via GitHub UI or gh CLI
    inputs:
      # ============================================================================
      # SCAN PRESETS - Quick enable/disable scan groups
      # ============================================================================
      scan_preset:
        description: 'Scan preset (overrides individual settings below)'
        required: false
        type: choice
        options:
          - 'custom'        # Use individual tool settings below
          - 'all'           # All scans (maximum coverage)
          - 'recommended'   # Essential security scans (default)
          - 'minimal'       # Critical scans only (fastest)
          - 'secrets_only'  # Only secret detection
        default: 'recommended'

      # ============================================================================
      # INDIVIDUAL SCAN CONTROLS (only used when preset = 'custom')
      # ============================================================================

      # Secrets Detection
      enable_gitleaks:
        description: 'üîê Gitleaks - Pattern-based secret detection (~30s)'
        required: false
        type: boolean
        default: true
      enable_trufflehog:
        description: 'üîê TruffleHog - Verified credential detection (~45s)'
        required: false
        type: boolean
        default: true

      # Static Application Security Testing (SAST)
      enable_semgrep:
        description: 'üîí Semgrep - Custom security rules SAST (~20s)'
        required: false
        type: boolean
        default: true

      # Infrastructure Security
      enable_shellcheck:
        description: 'üêö ShellCheck - Shell script security (~5s)'
        required: false
        type: boolean
        default: true
      enable_hadolint:
        description: 'üê≥ Hadolint - Dockerfile security (~3s)'
        required: false
        type: boolean
        default: true

      # Configuration Validation
      enable_yamllint:
        description: 'üìÑ yamllint - YAML validation (code quality, ~10s)'
        required: false
        type: boolean
        default: false
      enable_actionlint:
        description: '‚öôÔ∏è actionlint - GitHub Actions security (~5s)'
        required: false
        type: boolean
        default: true

      # Kubernetes Security
      enable_rbac_analyzer:
        description: 'üîë RBAC Analyzer - Privilege escalation analysis (~15s)'
        required: false
        type: boolean
        default: true

      # ============================================================================
      # ADVANCED OPTIONS
      # ============================================================================
      scan_git_history:
        description: 'üìú Scan full git history for secrets (slower)'
        required: false
        type: boolean
        default: false
      test_advisory:
        description: 'üß™ Test security advisory creation'
        required: false
        type: boolean
        default: false

  schedule:
    # Run weekly on Sunday at 00:00 UTC for baseline tracking
    - cron: '0 0 * * 0'

jobs:
  security-scan:
    name: Full Codebase Security Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write          # For SARIF upload

    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6.0.1
        with:
          fetch-depth: 0  # Full history for accurate analysis

      # ============================================================================
      # SCAN CONFIGURATION - Process preset and set runtime flags
      # ============================================================================
      - name: Configure scan settings
        id: config
        run: |
          # Process scan preset and set enable flags
          PRESET="${{ inputs.scan_preset || 'recommended' }}"

          echo "üìä Scan Preset: $PRESET"

          # Default values (for schedule trigger)
          RUN_GITLEAKS=true
          RUN_TRUFFLEHOG=true
          RUN_SEMGREP=true
          RUN_SHELLCHECK=true
          RUN_HADOLINT=true
          RUN_YAMLLINT=false
          RUN_ACTIONLINT=true
          RUN_RBAC=true

          # Apply preset configurations
          if [ "$PRESET" = "all" ]; then
            RUN_GITLEAKS=true
            RUN_TRUFFLEHOG=true
            RUN_SEMGREP=true
            RUN_SHELLCHECK=true
            RUN_HADOLINT=true
            RUN_YAMLLINT=true
            RUN_ACTIONLINT=true
            RUN_RBAC=true
          elif [ "$PRESET" = "recommended" ]; then
            # Default values (already set above)
            :
          elif [ "$PRESET" = "minimal" ]; then
            RUN_GITLEAKS=true
            RUN_TRUFFLEHOG=false
            RUN_SEMGREP=true
            RUN_SHELLCHECK=false
            RUN_HADOLINT=false
            RUN_YAMLLINT=false
            RUN_ACTIONLINT=true
            RUN_RBAC=false
          elif [ "$PRESET" = "secrets_only" ]; then
            RUN_GITLEAKS=true
            RUN_TRUFFLEHOG=true
            RUN_SEMGREP=false
            RUN_SHELLCHECK=false
            RUN_HADOLINT=false
            RUN_YAMLLINT=false
            RUN_ACTIONLINT=false
            RUN_RBAC=false
          elif [ "$PRESET" = "custom" ]; then
            # Use individual workflow inputs
            RUN_GITLEAKS=${{ inputs.enable_gitleaks }}
            RUN_TRUFFLEHOG=${{ inputs.enable_trufflehog }}
            RUN_SEMGREP=${{ inputs.enable_semgrep }}
            RUN_SHELLCHECK=${{ inputs.enable_shellcheck }}
            RUN_HADOLINT=${{ inputs.enable_hadolint }}
            RUN_YAMLLINT=${{ inputs.enable_yamllint }}
            RUN_ACTIONLINT=${{ inputs.enable_actionlint }}
            RUN_RBAC=${{ inputs.enable_rbac_analyzer }}
          fi

          # Set outputs for use in conditional steps
          echo "run_gitleaks=$RUN_GITLEAKS" >> $GITHUB_OUTPUT
          echo "run_trufflehog=$RUN_TRUFFLEHOG" >> $GITHUB_OUTPUT
          echo "run_semgrep=$RUN_SEMGREP" >> $GITHUB_OUTPUT
          echo "run_shellcheck=$RUN_SHELLCHECK" >> $GITHUB_OUTPUT
          echo "run_hadolint=$RUN_HADOLINT" >> $GITHUB_OUTPUT
          echo "run_yamllint=$RUN_YAMLLINT" >> $GITHUB_OUTPUT
          echo "run_actionlint=$RUN_ACTIONLINT" >> $GITHUB_OUTPUT
          echo "run_rbac=$RUN_RBAC" >> $GITHUB_OUTPUT

          # Summary
          echo "‚úÖ Scan Configuration:"
          echo "  - Gitleaks: $RUN_GITLEAKS"
          echo "  - TruffleHog: $RUN_TRUFFLEHOG"
          echo "  - Semgrep: $RUN_SEMGREP"
          echo "  - ShellCheck: $RUN_SHELLCHECK"
          echo "  - Hadolint: $RUN_HADOLINT"
          echo "  - yamllint: $RUN_YAMLLINT"
          echo "  - actionlint: $RUN_ACTIONLINT"
          echo "  - RBAC Analyzer: $RUN_RBAC"

      # ============================================================================
      # SECRETS DETECTION - Gitleaks (Pattern-based)
      # ============================================================================
      # Tool: Gitleaks v8.30.0
      # Purpose: Detects hardcoded secrets using regex patterns (API keys, passwords, tokens)
      # Coverage: ~100 built-in patterns for AWS, GitHub, Slack, etc.
      # Mode: Pattern-based detection (fast, some false positives possible)
      # Scope: By default scans current working tree only (--no-git flag)
      #        Set scan_git_history=true to scan full git history (slower, finds historical secrets)
      # Security Trade-off:
      #   - --no-git (default): Fast, low noise, but blind to secrets in deleted commits (CWE-312)
      #   - Full history: Comprehensive, finds all historical secrets, but includes false positives
      #   - Recommendation: Use --no-git for weekly scans, full history for incident response
      # Complement: TruffleHog scans full git history with credential verification
      #
      # Docker Image Pinning:
      # - Git tag: v8.30.0
      # - Docker digest (linux/amd64): sha256:105ac66a57b2bb8afb61a3b8a5dcc4817773d03724a7e8a515214cfe58225556
      # - Why digest?: Immutable reference, prevents tag retargeting attacks
      # - Verification: docker pull --platform linux/amd64 ghcr.io/gitleaks/gitleaks:v8.30.0 && docker inspect ghcr.io/gitleaks/gitleaks:v8.30.0 --format='{{.RepoDigests}}'

      - name: Run Gitleaks secrets scanner
        id: gitleaks
        if: steps.config.outputs.run_gitleaks == 'true'
        timeout-minutes: 10
        run: |
          # Conditionally add --no-git flag based on workflow input
          NO_GIT_FLAG="${{ !inputs.scan_git_history && '--no-git' || '' }}"

          docker run --rm \
            -v "${{ github.workspace }}:/repo" \
            ghcr.io/gitleaks/gitleaks@sha256:105ac66a57b2bb8afb61a3b8a5dcc4817773d03724a7e8a515214cfe58225556 \
            detect \
              --source /repo \
              $NO_GIT_FLAG \
              --report-format json \
              --report-path /repo/gitleaks.json \
              --redact \
              --verbose
        continue-on-error: true  # Don't block workflow, collect all findings

      # ============================================================================
      # SECRETS DETECTION - TruffleHog (Verified Credentials)
      # ============================================================================
      # Tool: TruffleHog v3.92.3
      # Purpose: Detects AND verifies live credentials by testing them against APIs
      # Coverage: 800+ credential types with API verification
      # Mode: Verified detection (slower, near-zero false positives)
      # Benefit: Confirms credentials are active/exploitable, not just pattern matches
      # Note: Only runs in full scans (not CodeRabbit PRs) due to API call overhead
      #
      # Docker Image Pinning:
      # - Git tag: 3.92.3
      # - Docker digest (linux/amd64): sha256:e42f126628f0a0ce4ee670bf62b71543eca5a3a2d3c590ff361091b841ac39c1
      # - Why digest?: Immutable reference, prevents tag retargeting attacks
      # - Source: https://github.com/trufflesecurity/trufflehog/pkgs/container/trufflehog
      # - Verification: docker run --rm ghcr.io/trufflesecurity/trufflehog@sha256:e42f126628f0a0ce4ee670bf62b71543eca5a3a2d3c590ff361091b841ac39c1 --version

      - name: Run TruffleHog secrets scanner
        id: trufflehog
        if: steps.config.outputs.run_trufflehog == 'true'
        timeout-minutes: 10
        run: |
          docker run --rm \
            -v "${{ github.workspace }}:/repo" \
            ghcr.io/trufflesecurity/trufflehog@sha256:e42f126628f0a0ce4ee670bf62b71543eca5a3a2d3c590ff361091b841ac39c1 \
            filesystem /repo \
              --only-verified \
              --json > trufflehog.json 2> trufflehog-errors.log || true
          # Log errors if any occurred
          if [ -s trufflehog-errors.log ]; then
            echo "::warning::TruffleHog reported errors, check trufflehog-errors.log artifact"
            cat trufflehog-errors.log
          fi
        continue-on-error: true  # Don't block workflow, collect all findings

      # ============================================================================
      # CUSTOM SECURITY RULES - Semgrep
      # ============================================================================
      # Tool: Semgrep v1.145.0
      # Purpose: Custom SAST rules for RBAC, OWASP, Kubernetes operator patterns
      # Coverage: 27 operator-focused rules (11 RBAC, excludes SQL/command injection)
      # Config: semgrep.yaml in repository root
      # Output: SARIF format for GitHub Security tab integration
      #
      # Docker Image Pinning:
      # - Git tag: v1.145.0
      # - Docker digest (linux/amd64): sha256:1f0850c540140c6da68811b21012fd26e91e5323daae245b0a71e70b72a89d2a
      # - Why digest?: Immutable reference, prevents Docker Hub tag retargeting attacks
      # - Verification: podman manifest inspect semgrep/semgrep:1.145.0 | jq -r '.manifests[] | select(.platform.architecture=="amd64") | .digest'

      - name: Run Semgrep security analysis
        id: semgrep
        if: steps.config.outputs.run_semgrep == 'true'
        run: |
          docker run --rm \
            -v "${{ github.workspace }}:/src" \
            -e SEMGREP_TIMEOUT=300 \
            semgrep/semgrep@sha256:1f0850c540140c6da68811b21012fd26e91e5323daae245b0a71e70b72a89d2a \
            semgrep scan \
              --config /src/.github/config/semgrep.yaml \
              --sarif \
              --output /src/semgrep.sarif \
              /src
        continue-on-error: true

      - name: Upload Semgrep SARIF results
        if: always() && hashFiles('semgrep.sarif') != ''
        uses: github/codeql-action/upload-sarif@1b168cd39490f61582a9beae412bb7057a6b2c4e  # v4.31.8
        with:
          sarif_file: semgrep.sarif
          category: semgrep

      # ============================================================================
      # SHELL SCRIPT SECURITY - ShellCheck
      # ============================================================================
      # Tool: ShellCheck v0.10.0
      # Purpose: Static analysis for shell scripts (bash, sh)
      # Detects: Quoting issues, command injection, dangerous patterns
      # Coverage: ALL .sh files including CI/CD, build scripts, and examples
      # Common findings: Unquoted variables, missing error handling, SC2086, SC2046
      # OWASP: Prevents CWE-78 (OS Command Injection)
      # Note: Scans all scripts intentionally - build/CI scripts are attack vectors

      - name: Install ShellCheck
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck

      - name: Run ShellCheck
        id: shellcheck
        if: steps.config.outputs.run_shellcheck == 'true'
        run: |
          # Find all shell scripts and run shellcheck, outputting JSON
          # Scans ALL scripts including .github/scripts, hack/, tests/
          # Excludes only vendor/ to avoid third-party code noise
          find . -name "*.sh" -type f -not -path "*/vendor/*" -print0 | \
            xargs -0 --no-run-if-empty shellcheck --format=json --severity=warning > shellcheck.json || true
          # Ensure valid JSON output even if no scripts found
          [ -s shellcheck.json ] || echo "[]" > shellcheck.json
        continue-on-error: true

      # ============================================================================
      # DOCKERFILE SECURITY - Hadolint
      # ============================================================================
      # Tool: Hadolint v2.14.0
      # Purpose: Dockerfile linter enforcing best practices
      # Detects: Secrets in ENV, unpinned base images, running as root
      # Coverage: All Dockerfile* files (including Dockerfile.dev, etc.)
      # Standards: Enforces Docker best practices and CIS Benchmark recommendations
      # Output: SARIF format for GitHub Security tab integration
      #
      # Docker Image Pinning:
      # - Git tag: v2.14.0-alpine
      # - Docker digest: sha256:7aba693c1442eb31c0b015c129697cb3b6cb7da589d85c7562f9deb435a6657c
      # - Why digest?: Immutable reference, prevents tag retargeting attacks
      # - Source: https://github.com/hadolint/hadolint/pkgs/container/hadolint/versions
      # - Verification: docker run --rm --entrypoint hadolint ghcr.io/hadolint/hadolint@sha256:7aba693c1442eb31c0b015c129697cb3b6cb7da589d85c7562f9deb435a6657c --version

      - name: Run Hadolint on Dockerfiles
        id: hadolint
        if: steps.config.outputs.run_hadolint == 'true'
        run: |
          # Find all Dockerfiles excluding test/example/vendor directories
          # Use explicit path exclusions to avoid scanning test fixtures
          DOCKERFILES=$(find . -type f -name "Dockerfile*" \
            -not -path "*/examples/*" \
            -not -path "*/testdata/*" \
            -not -path "*/test/*" \
            -not -path "*/tests/*" \
            -not -path "*/docs/*" \
            -not -path "*/vendor/*" \
            -not -path "*/.git/*")

          if [ -z "$DOCKERFILES" ]; then
            echo "No Dockerfiles found to scan"
            # Create empty SARIF file for consistency
            echo '{"version":"2.1.0","$schema":"https://json.schemastore.org/sarif-2.1.0.json","runs":[]}' > hadolint.sarif
            exit 0
          fi

          # Run hadolint on each Dockerfile and combine results
          docker run --rm -i \
            -v "${{ github.workspace }}:/workspace" \
            -w /workspace \
            ghcr.io/hadolint/hadolint@sha256:7aba693c1442eb31c0b015c129697cb3b6cb7da589d85c7562f9deb435a6657c \
            hadolint --config .github/config/hadolint.yaml --format sarif $DOCKERFILES > hadolint.sarif || true
        continue-on-error: true

      - name: Upload Hadolint SARIF results
        if: always() && hashFiles('hadolint.sarif') != ''
        uses: github/codeql-action/upload-sarif@1b168cd39490f61582a9beae412bb7057a6b2c4e  # v4.31.8
        with:
          sarif_file: hadolint.sarif
          category: hadolint

      # ============================================================================
      # YAML VALIDATION - yamllint
      # ============================================================================
      # Tool: yamllint v1.37.1
      # Purpose: Validates YAML syntax and style for Kubernetes manifests
      # Detects: Syntax errors, inconsistent indentation, line length violations
      # Config: .yamllint (strict truthy checking: yes/no/true/false enforcement)
      # Coverage: All .yaml and .yml files (manifests, workflows, configs)
      # Benefit: Catches deployment-breaking YAML errors before runtime
      # Output: parsable format (file:line:col: [level] message (rule))
      # Note: JSON format not supported - PR #245 never merged

      - name: Install yamllint
        run: |
          python -m pip install --upgrade pip
          pip install yamllint==1.37.1

      - name: Run yamllint
        id: yamllint
        if: steps.config.outputs.run_yamllint == 'true'
        run: |
          yamllint -f parsable . > yamllint.txt
        continue-on-error: true

      # ============================================================================
      # GITHUB ACTIONS WORKFLOW VALIDATION - actionlint
      # ============================================================================
      # Tool: actionlint v1.7.8
      # Purpose: Validates GitHub Actions workflow syntax and best practices
      # Detects: Invalid expressions, incorrect job dependencies, unsafe permissions
      # Coverage: All .github/workflows/*.yml files
      # Benefit: Catches workflow-specific issues that yamllint doesn't validate
      # Complements: yamllint (general YAML) + Semgrep (secrets/security)
      # Output: Human-readable format with color highlighting
      #
      # Docker Image Pinning:
      # - Git tag: v1.7.8
      # - Docker digest (linux/amd64): sha256:32a5c57cebdc2aad2ca4083dcdf08a784795b06adde2082fd2ef724445582390
      # - Why digest?: Immutable reference, prevents tag retargeting attacks
      # - Verification: docker pull rhysd/actionlint:1.7.8 && docker inspect rhysd/actionlint:1.7.8 --format='{{.RepoDigests}}'

      - name: Run actionlint on GitHub Actions workflows
        id: actionlint
        if: steps.config.outputs.run_actionlint == 'true'
        timeout-minutes: 5
        run: |
          docker run --rm \
            -v "${{ github.workspace }}:/repo" \
            -w /repo \
            rhysd/actionlint@sha256:32a5c57cebdc2aad2ca4083dcdf08a784795b06adde2082fd2ef724445582390 \
            --no-color > actionlint.txt 2>&1
        continue-on-error: true

      # ============================================================================
      # KUBERNETES MANIFEST SECURITY - kube-linter
      # ============================================================================
      # SKIPPED FOR THIS REPOSITORY
      # Reason: kube-auth-proxy is a Go application (OAuth2 proxy), not a Kubernetes operator
      # It does not have:
      #   - A Makefile with 'prepare' target
      #   - config/manifests directory with kustomize configs
      #   - Kubernetes manifests requiring validation
      # kube-linter is only applicable to operator repositories like opendatahub-operator

      # - name: Set up Go for kube-linter
      #   uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00  # v6.0.0
      #   with:
      #     go-version-file: go.mod
      #
      # - name: Run kube-linter
      #   id: kubelinter
      #   timeout-minutes: 5
      #   run: |
      #     # Prepare kustomize and render manifests
      #     make prepare
      #     TMP_FILE=$(mktemp /tmp/kube-lint.XXXXXX.yaml)
      #     ./bin/kustomize build config/manifests > "$TMP_FILE"
      #
      #     # Run kube-linter with JSON output for comprehensive report
      #     go run golang.stackrox.io/kube-linter/cmd/kube-linter@v0.7.6 lint \
      #       --config .kube-linter.yaml \
      #       --format json \
      #       "$TMP_FILE" > kube-linter.json || true
      #
      #     # Run kube-linter with SARIF output for GitHub Security tab
      #     go run golang.stackrox.io/kube-linter/cmd/kube-linter@v0.7.6 lint \
      #       --config .kube-linter.yaml \
      #       --format sarif \
      #       "$TMP_FILE" > kube-linter.sarif || true
      #
      #     rm -f "$TMP_FILE"
      #   continue-on-error: true
      #
      # - name: Upload kube-linter SARIF results
      #   if: always() && hashFiles('kube-linter.sarif') != ''
      #   uses: github/codeql-action/upload-sarif@1b168cd39490f61582a9beae412bb7057a6b2c4e  # v4.31.8
      #   with:
      #     sarif_file: kube-linter.sarif
      #     category: kube-linter

      # ============================================================================
      # RBAC PRIVILEGE CHAIN ANALYSIS - Custom Script
      # ============================================================================
      # Tool: Custom Python analyzer (.github/scripts/rbac-analyzer.py)
      # Purpose: Maps privilege escalation chains in Kubernetes RBAC
      # Analysis: ClusterRole ‚Üí RoleBinding ‚Üí ServiceAccount ‚Üí Pod relationships
      # Detects:
      #   - Dangerous verbs (escalate, impersonate, bind)
      #   - Dangerous resources (secrets, pods/exec, pods/attach)
      #   - Wildcard permissions (*, resources/verbs)
      #   - Escalation combos (create/patch/update on roles/bindings)
      #   - Pods with cluster-admin access
      #   - RoleBinding ‚Üí ClusterRole misuse (namespace privilege escalation)
      # Output: Structured findings with CRITICAL/HIGH/WARNING/INFO severity
      # Exit codes: Configurable via --fail-on (production: HIGH, fails on HIGH+ findings)
      # Exclusions: test, examples, docs, bin, .github/workflows
      #
      # Why custom?: No existing tool maps full Pod‚ÜíSA‚ÜíRole privilege chains
      # Complement: Semgrep catches individual RBAC issues, this finds relationships

      - name: Setup Python for RBAC Analysis
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548  # v6.1.0
        with:
          python-version: '3.11'

      - name: Install PyYAML for RBAC analyzer
        run: python -m pip install "pyyaml==6.0.3"

      - name: Run RBAC Privilege Chain Analyzer (Public Version)
        id: rbac_analyzer
        run: |
          # Generate public version (no attack scenarios) for artifacts
          python .github/scripts/rbac-analyzer.py . --fail-on HIGH 2>&1 | tee rbac-analysis.md
          echo "## üîê RBAC Privilege Chain Analysis (Public)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat rbac-analysis.md >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

      - name: Generate RBAC Analysis with Attack Scenarios (Private Version)
        id: rbac_analyzer_private
        if: always()
        run: |
          # Generate private version with detailed attack scenarios for security advisory
          python .github/scripts/rbac-analyzer.py . --fail-on HIGH --include-attack-scenarios > rbac-analysis-private.md 2>&1
          echo "‚úÖ Private RBAC analysis with attack scenarios generated (for security advisory)"
        continue-on-error: true

      - name: Upload RBAC analysis report
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: rbac-analysis-report
          path: rbac-analysis.md
          retention-days: 30

      # ============================================================================
      # COMPREHENSIVE SECURITY REPORT GENERATION
      # ============================================================================
      # Tool: Custom Python report generator (.github/scripts/generate-security-report.py)
      # Purpose: Aggregates all tool outputs into a unified markdown report
      # Inputs: JSON/SARIF from all tools (Gitleaks, TruffleHog, Semgrep, etc.)
      # Output: Comprehensive markdown report with:
      #   - Executive summary with overall security posture
      #   - Findings organized by severity (CRITICAL/HIGH/MEDIUM/LOW/INFO)
      #   - File paths, line numbers, descriptions, remediation guidance
      #   - RBAC privilege chain analysis inclusion
      #   - Prioritized recommendations
      # Format: Markdown suitable for security review and JIRA attachments
      # Artifact: Uploaded with org-configured retention period

      - name: Generate comprehensive security report
        if: always()
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          python .github/scripts/generate-security-report.py \
            --output security-report.md \
            --json-summary security-summary.json \
            --yamllint-report yamllint-report.md \
            --workspace . \
            --yamllint-limit 30
          echo "## Comprehensive Security Report Generated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "A detailed security report has been generated and uploaded as an artifact." >> $GITHUB_STEP_SUMMARY
          echo "Download it from the workflow artifacts section for full details." >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

      - name: Upload comprehensive security report
        if: always() && hashFiles('security-report.md') != ''
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: comprehensive-security-report
          path: |
            security-report.md
            security-summary.json
            yamllint-report.md
          retention-days: 90

      # ============================================================================
      # DETERMINE ADVISORY SEVERITY
      # ============================================================================
      # Dynamically determine security advisory severity based on actual findings
      # in the comprehensive security report, rather than using hardcoded 'high'.

      - name: Determine advisory severity
        if: always() && hashFiles('security-summary.json') != ''
        id: severity
        run: |
          # Check security-summary.json for actual finding counts
          critical=$(jq -r '.severity_counts.critical // 0' security-summary.json)
          high=$(jq -r '.severity_counts.high // 0' security-summary.json)
          medium=$(jq -r '.severity_counts.medium // 0' security-summary.json)

          if [[ "$critical" =~ ^[0-9]+$ ]] && (( critical > 0 )); then
            echo "severity=critical" >> "$GITHUB_OUTPUT"
            echo "üìä Detected CRITICAL findings ($critical) - advisory severity: critical"
          elif [[ "$high" =~ ^[0-9]+$ ]] && (( high > 0 )); then
            echo "severity=high" >> "$GITHUB_OUTPUT"
            echo "üìä Detected HIGH findings ($high) - advisory severity: high"
          elif [[ "$medium" =~ ^[0-9]+$ ]] && (( medium > 0 )); then
            echo "severity=moderate" >> "$GITHUB_OUTPUT"
            echo "üìä Detected MEDIUM findings ($medium) - advisory severity: moderate"
          else
            echo "severity=low" >> "$GITHUB_OUTPUT"
            echo "üìä No high-severity findings - advisory severity: low"
          fi
        continue-on-error: true

      # ============================================================================
      # AGGREGATE RESULTS
      # ============================================================================

      - name: Generate security scan summary
        if: always()
        env:
          GITLEAKS_OUTCOME: ${{ steps.gitleaks.outcome }}
          TRUFFLEHOG_OUTCOME: ${{ steps.trufflehog.outcome }}
          SEMGREP_OUTCOME: ${{ steps.semgrep.outcome }}
          SHELLCHECK_OUTCOME: ${{ steps.shellcheck.outcome }}
          HADOLINT_OUTCOME: ${{ steps.hadolint.outcome }}
          YAMLLINT_OUTCOME: ${{ steps.yamllint.outcome }}
          ACTIONLINT_OUTCOME: ${{ steps.actionlint.outcome }}
          RBAC_OUTCOME: ${{ steps.rbac_analyzer.outcome }}
        run: |
          # Function to extract severity summary from JSON (robust parsing with jq)
          get_severity_badge() {
            local tool_name="$1"
            local json_file="security-summary.json"

            if [[ ! -f "$json_file" ]]; then
              echo ""
              return
            fi

            # Verify jq is available
            if ! command -v jq &> /dev/null; then
              echo "<br/>‚ö†Ô∏è jq not available"
              return
            fi

            # Validate JSON structure before parsing
            if ! jq -e ".tools[\"$tool_name\"]" "$json_file" &>/dev/null; then
              echo ""
              return
            fi

            # Extract severity counts from JSON using jq
            local critical=$(jq -r ".tools[\"$tool_name\"].critical // 0" "$json_file")
            local high=$(jq -r ".tools[\"$tool_name\"].high // 0" "$json_file")
            local medium=$(jq -r ".tools[\"$tool_name\"].medium // 0" "$json_file")
            local low=$(jq -r ".tools[\"$tool_name\"].low // 0" "$json_file")
            local total=$(jq -r ".tools[\"$tool_name\"].total // 0" "$json_file")

            if [[ "$total" == "0" ]]; then
              echo ""
              return
            fi

            # Build severity summary with non-zero counts
            local summary=""
            [[ $critical -gt 0 ]] && summary="${summary}üî¥ Critical: $critical "
            [[ $high -gt 0 ]] && summary="${summary}üü† High: $high "
            [[ $medium -gt 0 ]] && summary="${summary}üü° Medium: $medium "
            [[ $low -gt 0 ]] && summary="${summary}üîµ Low: $low "

            # Trim trailing space
            summary="${summary% }"

            # Fallback: if no severity breakdown, just show total
            if [[ -z "$summary" ]]; then
              summary="$total issues"
            fi

            echo "<br/>$summary"
          }

          # Function to determine status based on outcome and output file validity
          get_status() {
            local outcome="$1"
            local output_file="$2"

            if [[ "$outcome" == "success" ]]; then
              echo "‚úÖ|Passed"
            elif [[ "$outcome" == "failure" ]]; then
              if [[ -f "$output_file" && -s "$output_file" ]]; then
                # Verify file is valid JSON/SARIF (for tools that produce such output)
                case "$output_file" in
                  *.json)
                    if jq empty "$output_file" 2>/dev/null; then
                      echo "üîí|Issues Found"
                    else
                      echo "‚ùå|Failed (invalid JSON output)"
                    fi
                    ;;
                  *.sarif)
                    if jq empty "$output_file" 2>/dev/null; then
                      echo "üîí|Issues Found"
                    else
                      echo "‚ùå|Failed (invalid SARIF)"
                    fi
                    ;;
                  *)
                    # For text/markdown files like rbac-analysis.md
                    echo "üîí|Issues Found"
                    ;;
                esac
              else
                echo "‚ùå|Failed (no output or empty file)"
              fi
            elif [[ "$outcome" == "cancelled" ]]; then
              echo "üö´|Cancelled"
            elif [[ "$outcome" == "skipped" ]]; then
              echo "‚è≠Ô∏è|Skipped"
            else
              echo "‚ùì|Unknown"
            fi
          }

          echo "## üîí Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Tool | Purpose | Status | Result |" >> $GITHUB_STEP_SUMMARY
          echo "|------|---------|--------|--------|" >> $GITHUB_STEP_SUMMARY

          # Gitleaks
          status_result=$(get_status "$GITLEAKS_OUTCOME" "gitleaks.json")
          severity_summary=$(get_severity_badge "Gitleaks")
          echo "| Gitleaks | Secrets detection (pattern-based) | ${status_result%%|*} | ${status_result##*|}${severity_summary} |" >> $GITHUB_STEP_SUMMARY

          # TruffleHog
          status_result=$(get_status "$TRUFFLEHOG_OUTCOME" "trufflehog.json")
          severity_summary=$(get_severity_badge "TruffleHog")
          echo "| TruffleHog | Secrets detection (verified, 800+ types) | ${status_result%%|*} | ${status_result##*|}${severity_summary} |" >> $GITHUB_STEP_SUMMARY

          # Semgrep
          status_result=$(get_status "$SEMGREP_OUTCOME" "semgrep.sarif")
          severity_summary=$(get_severity_badge "Semgrep")
          echo "| Semgrep | Custom security rules (27 operator-focused) | ${status_result%%|*} | ${status_result##*|}${severity_summary} |" >> $GITHUB_STEP_SUMMARY

          # ShellCheck
          status_result=$(get_status "$SHELLCHECK_OUTCOME" "shellcheck.json")
          severity_summary=$(get_severity_badge "ShellCheck")
          echo "| ShellCheck | Shell script security | ${status_result%%|*} | ${status_result##*|}${severity_summary} |" >> $GITHUB_STEP_SUMMARY

          # Hadolint
          status_result=$(get_status "$HADOLINT_OUTCOME" "hadolint.sarif")
          severity_summary=$(get_severity_badge "Hadolint")
          echo "| Hadolint | Dockerfile security | ${status_result%%|*} | ${status_result##*|}${severity_summary} |" >> $GITHUB_STEP_SUMMARY

          # yamllint
          status_result=$(get_status "$YAMLLINT_OUTCOME" "yamllint.txt")
          severity_summary=$(get_severity_badge "yamllint")
          echo "| yamllint | YAML validation | ${status_result%%|*} | ${status_result##*|}${severity_summary} |" >> $GITHUB_STEP_SUMMARY

          # actionlint
          status_result=$(get_status "$ACTIONLINT_OUTCOME" "actionlint.txt")
          severity_summary=$(get_severity_badge "actionlint")
          echo "| actionlint | GitHub Actions workflow validation | ${status_result%%|*} | ${status_result##*|}${severity_summary} |" >> $GITHUB_STEP_SUMMARY

          # RBAC Analyzer
          status_result=$(get_status "$RBAC_OUTCOME" "rbac-analysis.md")
          severity_summary=$(get_severity_badge "RBAC Analyzer")
          echo "| RBAC Analyzer | Privilege chain analysis | ${status_result%%|*} | ${status_result##*|}${severity_summary} |" >> $GITHUB_STEP_SUMMARY

          # Overall status
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "$GITLEAKS_OUTCOME" == "success" ]] && \
             [[ "$TRUFFLEHOG_OUTCOME" == "success" ]] && \
             [[ "$SEMGREP_OUTCOME" == "success" ]] && \
             [[ "$SHELLCHECK_OUTCOME" == "success" ]] && \
             [[ "$HADOLINT_OUTCOME" == "success" ]] && \
             [[ "$YAMLLINT_OUTCOME" == "success" ]] && \
             [[ "$ACTIONLINT_OUTCOME" == "success" ]] && \
             [[ "$RBAC_OUTCOME" == "success" ]]; then
            echo "‚úÖ **All security scans passed - no issues found**" >> $GITHUB_STEP_SUMMARY
          else
            # Check if any tools actually failed (vs just found issues)
            has_failures=false
            has_incomplete=false
            for outcome in "$GITLEAKS_OUTCOME" "$TRUFFLEHOG_OUTCOME" "$SEMGREP_OUTCOME" "$SHELLCHECK_OUTCOME" "$HADOLINT_OUTCOME" "$YAMLLINT_OUTCOME" "$ACTIONLINT_OUTCOME" "$RBAC_OUTCOME"; do
              if [[ "$outcome" == "failure" ]]; then
                # At least one tool had a non-success outcome (either failed or found issues)
                has_failures=true
              elif [[ "$outcome" == "cancelled" || "$outcome" == "skipped" ]]; then
                # At least one tool was cancelled or skipped
                has_incomplete=true
              fi
            done

            if $has_failures; then
              echo "‚ö†Ô∏è **Security issues detected - review required**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Download the **comprehensive-security-report** artifact for detailed findings." >> $GITHUB_STEP_SUMMARY
            elif $has_incomplete; then
              echo "‚ÑπÔ∏è **Security scans incomplete - review required**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Some scans were cancelled or skipped. Review the workflow logs for details." >> $GITHUB_STEP_SUMMARY
            fi
          fi

      - name: Fail workflow on critical/high findings
        if: always() && hashFiles('security-summary.json') != ''
        run: |
          # Verify jq is available
          if ! command -v jq &> /dev/null; then
            echo "‚ö†Ô∏è jq not available - skipping critical findings check"
            exit 0
          fi

          critical=$(jq -r '.severity_counts.critical // 0' security-summary.json)
          high=$(jq -r '.severity_counts.high // 0' security-summary.json)

          # Validate numeric values
          if [[ "$critical" =~ ^[0-9]+$ ]] && [[ $critical -gt 0 ]]; then
            echo "‚ùå Workflow failed: $critical CRITICAL findings detected"
            echo "Review the comprehensive-security-report artifact for details"
            exit 1
          fi

          if [[ "$high" =~ ^[0-9]+$ ]] && [[ $high -gt 0 ]]; then
            echo "‚ùå Workflow failed: $high HIGH severity findings detected"
            echo "Review the comprehensive-security-report artifact for details"
            exit 1
          fi

      # ============================================================================
      # CREATE SECURITY ADVISORY ON CRITICAL FINDINGS
      # ============================================================================
      # Only triggered by critical security tools (secrets detection, SAST, RBAC analysis).
      # Excluded: linters (yamllint, shellcheck, hadolint) - these flag style/best-practices.
      # Severity is determined dynamically from the comprehensive security report.
      #
      # GitHub App Authentication:
      # - Requires a GitHub App with repository_advisories:write permission
      # - GITHUB_TOKEN does not support the repository_advisories permission scope
      # - App credentials (App ID and Private Key) must be stored as repository secrets
      # - Uses continue-on-error to allow workflow to complete even if secrets are missing

      - name: Generate GitHub App token
        if: |
          inputs.test_advisory == true ||
          steps.gitleaks.outcome == 'failure' ||
          steps.trufflehog.outcome == 'failure' ||
          steps.semgrep.outcome == 'failure' ||
          steps.rbac_analyzer.outcome == 'failure'
        id: app_token
        continue-on-error: true
        uses: actions/create-github-app-token@5d869da34e18e7287c1daad50e0b8ea0f506ce69  # v1.11.0
        with:
          app-id: ${{ secrets.SECURITY_APP_ID }}
          private-key: ${{ secrets.SECURITY_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}

      - name: Create private security advisory on critical findings
        if: |
          steps.app_token.outcome == 'success' &&
          (inputs.test_advisory == true ||
           steps.gitleaks.outcome == 'failure' ||
           steps.trufflehog.outcome == 'failure' ||
           steps.semgrep.outcome == 'failure' ||
           steps.rbac_analyzer.outcome == 'failure')
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b  # v7.0.1
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const createAdvisory = require('./.github/scripts/create-security-advisory.js')
            await createAdvisory({
              github,
              context,
              core,
              severity: '${{ steps.severity.outputs.severity || 'high' }}',
              workflowRunUrl: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}',
              commit: '${{ github.sha }}',
              branch: '${{ github.ref_name }}'
            })
